#!/usr/bin/env node

process.title = 'intern';

var fs = require('fs'),
	cli = require('../lib/cli'),
	semver = require('semver'),
	info = cli.info,
	path = require('path'),
	options = cli.init(),
	isGeezer = false,
	intern,
	options,
	config,
	runner;

intern = cli.loadInternPackage();
if (!intern) {
	cli.die('Missing local Intern', 1);
}
if (semver.lt(intern.package.version, '1.6.0')) {
	cli.die('Intern 1.6.0 or above is required', 1);
}

isGeezer = intern.package.name === 'intern-geezer';

if (options.version) {
	cli.die('Intern CLI v0.1\nIntern v' + intern.package.version);
}
if (options.help) {
	cli.die(cli.help());
}

if (!options.no_color) {
	cli.colorizeConsole({ debug: options.verbose });
}

if (options.verbose) {
	console.log('Intern path:  ', intern.path);
	console.log('Intern name:  ', intern.package.name);
	console.log('Options:      ', options);
}

// esure a config file was specified
config = options.config;
if (!config) {
	console.warn('Config file is required');
	cli.die(cli.help(), 1);
}

var configFile = config;
if (configFile.slice(-3) !== '.js') {
	configFile += '.js';
}
if (!fs.existsSync(configFile)) {
	cli.die('Config file "' + configFile + '" does not exist');
}

var runType = 'client',
	req = require(intern.path + '/node_modules/dojo/dojo');

if (options.webdriver || options.sauce) {
	runType = 'runner';
}

// clear and reset process.argv[2:] -- the only option we want is the config, everything else will be
// modified in the config object directly
process.argv = process.argv.slice(0, 2);
process.argv.push('config=' + config);

req([ config ], function (testConfig) {
	// 
	// Update the testConfig directly for options that pertain only to the runner
	//

	if ( options.no_instrument) {
		testConfig.excludeInstrumentation = /./;
	}

	if (options.remote) {
		var remote = options.remote.split(':');
		testConfig.webdriver.host = remote[0];
		if (remote.length > 1) {
			testConfig.webdriver.port = remote[1];
		}
	}

	if (options.proxy) {
		var proxy = options.proxy.split(':'),
			port = testConfig.proxyPort;
		if (proxy.length > 1) {
			port = Number(proxy[1]);
		}
		testConfig.proxyPort = Number(port);
		testConfig.proxyUrl = 'http://' + proxy[0] + ':' + port;
	}

	if (options.browser) {
		testConfig.environments = [];
		options.browser.forEach(function (name) {
			testConfig.environments.push({ browserName: name });
		});
	}

	testConfig.useSauceConnect = options.sauce;
	if (options.sauce_user) {
		testConfig.webdriver.username = options.sauce_user;
	}
	if (options.sauce_key) {
		testConfig.webdriver.accessKey = options.sauce_key;
	}

	//
	// Update the process arguments for options that pertain to the client
	//

	if (options.suite) {
		options.suite.forEach(function (suite) {
			suite = options.suiteBase ? options.suiteBase + '/' + suite : suite;
			process.argv.push('suites=' + suite);
		});
	}

	if (options.reporter) {
		options.reporter.forEach(function (name) {
			process.argv.push('reporters=' + name);
		});
	}

	if (options.keep_remote) {
		process.argv.push('leaveRemoteOpen');
	}

	if (options.proxy_only) {
		process.argv.push('proxyOnly');
	}

	if (options.arg) {
		options.args.forEach(function (arg) {
			process.argv.push(arg);
		});
	}

	// configure the loader (normally handled by Intern's runner and client)
	var internConfig = global.__internConfig = {
		baseUrl: process.cwd(),
		packages: [
			{ name: 'intern', location: intern.path }
		],
		map: {
			intern: {
				dojo: 'intern/node_modules/dojo',
				chai: 'intern/node_modules/chai/chai',
				//sinon: 'intern/node_modules/sinon'
			},
			'*': {
				'intern/dojo': 'intern/node_modules/dojo'
			}
		}
	};

	if (isGeezer) {
		internConfig.async = true;
		internConfig.deps = [ 'intern/runner' ];
		internConfig.tlmSiblingOfDojo = false;
		internConfig.useDeferredInstrumentation = false;
	}

	if (options.verbose) {
		console.log('Intern configuration:', testConfig);
	}

	// start Intern
	if (isGeezer) {
		req(global.__internConfig, [ 'dojo/dojo' ]);
	}
	else {
		req(global.__internConfig, [ 'intern/' + runType ]);
	}
});

// vim:filetype=javascript
